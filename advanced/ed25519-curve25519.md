# Ed25519 to X25519 keys conversion

Ed25519 keys can be converted to X25519 keys, so that the same key pair can be used both for authenticated encryption (`crypto_box`) and for signatures (`crypto_sign`).

Before considering this operation, please read these relevant paragraphs from the FAQ:

  - [Do I need to add a signature to encrypted messages to detect if they have been tampered with?](../quickstart#do-i-need-to-add-a-signature-to-encrypted-messages-to-detect-if-they-have-been-tampered-with)
  - [How can I sign and encrypt using the same key pair?](../quickstart#how-can-i-sign-and-encrypt-using-the-same-key-pair)

## Example

``` c
unsigned char ed25519_pk[crypto_sign_ed25519_PUBLICKEYBYTES];
unsigned char ed25519_skpk[crypto_sign_ed25519_SECRETKEYBYTES];
unsigned char x25519_pk[crypto_scalarmult_curve25519_BYTES];
unsigned char x25519_sk[crypto_scalarmult_curve25519_BYTES];

crypto_sign_ed25519_keypair(ed25519_pk, ed25519_skpk);

crypto_sign_ed25519_pk_to_curve25519(x25519_pk, ed25519_pk);
crypto_sign_ed25519_sk_to_curve25519(x25519_sk, ed25519_skpk);
```

## Usage

``` c
int crypto_sign_ed25519_pk_to_curve25519(unsigned char *x25519_pk,
                                         const unsigned char *ed25519_pk);
```

The `crypto_sign_ed25519_pk_to_curve25519()` function converts an Ed25519 public key `ed25519_pk` to an X25519 public key and stores it into `x25519_pk`.

``` c
int crypto_sign_ed25519_sk_to_curve25519(unsigned char *x25519_sk,
                                         const unsigned char *ed25519_sk);
```

The `crypto_sign_ed25519_sk_to_curve25519()` function converts an Ed25519 secret key `ed25519_sk` to an X25519 secret key and stores it into `x25519_sk`.

In order to save CPU cycles and prevent key mismatches, the `crypto_sign_open()` and `crypto_sign_verify_detached()` functions expect Ed25519 secret keys generated by `crypto_sign_keypair()` or `crypto_sign_seed_keypair()`. These keys are 64 byte long.

However, the `crypto_sign_ed25519_sk_to_curve25519()` function accepts both these 64 byte keys, and the 32 byte seed returned by `crypto_sign_ed25519_sk_to_seed()`.

## Notes

If you can afford it, using distinct keys for signing and for encryption is still highly recommended. Signing keys are usually long-term keys, while keys used for key exchange should rather be ephemeral.

An alternative is do the ECDH operation over the Edwards curve, avoiding the conversion altogether.

In order to do this, the `crypto_scalarmult_ed25519()` function is available.

However, that still requires computing the Edwards25519 secret key from the Ed25519 seed.

The following code illustrates how to do it:

```c
unsigned char ed25519_pk[crypto_sign_PUBLICKEYBYTES];
unsigned char ed25519_sk[crypto_sign_SECRETKEYBYTES];
unsigned char seed[crypto_sign_SEEDBYTES];
unsigned char edwards25519_pk[crypto_scalarmult_ed25519_BYTES];
unsigned char edwards25519_sk[crypto_scalarmult_ed25519_SCALARBYTES];
unsigned char h[crypto_hash_sha512_BYTES];

// create an Ed25519 keypair
crypto_sign_keypair(ed25519_pk, ed25519_sk);

// Extract the seed from the Ed25519 secret key
crypto_sign_ed25519_sk_to_seed(seed, ed25519_sk);

// Ed25519 internally derives two values from the seed; this is how it does it.
crypto_hash_sha512(h, seed, sizeof seed);

// The first half of the output correspond to the Edwards25519 scalar.
memcpy(edwards25519_sk, h, sizeof edwards25519_sk);

// The Ed25519 public key is actually the Edwards25519 base point
// multiplied by the Edwards25519 scalar.
crypto_scalarmult_ed25519_base(edwards25519_pk, edwards25519_sk);

// (edwards25519_pk, edwards25519_sk) can be used for Diffie-Hellman
// using crypto_scalarmult_ed25519() if you like to. Do not forget to
// hash the result in order to get a key suitable for encryption.
```

## References

  - [On using the same key pair for Ed25519 and an X25519 based KEM](https://eprint.iacr.org/2021/509.pdf) - E. Thormarker
